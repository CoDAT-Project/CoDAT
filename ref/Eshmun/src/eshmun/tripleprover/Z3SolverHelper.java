package eshmun.tripleprover;

import com.microsoft.z3.*;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Paths;
import java.util.*;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BailErrorStrategy;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

public class Z3SolverHelper {
    /**
     * IMPLEMENTATION:
     * This class helps in translating to SMT syntax and generating the smt file syntax and runs to solve the formula.
     * It generate test.smt file, runs it with the Z3 api and solves it to get if formula is valid or not
     * Authors : Chukri Soueidi
     * Created on 5/6/17.
     */

    public static boolean SolvePSQ(String p){

           /*
        IMPLEMENTATION SKETCH:  The main function take args(0) text file and runs it on the HFL ANTLR parser.
        This will fill the AST using the ExtendedHFLListener
        After that the weakest precondition is generated by calling WeakestPrecondition.wp() to get a formula
        Then it calls Z3.solver on the generated formula to get the output.
      */

       ANTLRInputStream input = new ANTLRInputStream(p);

       // create a lexer that feeds off of input CharStream
       HFLLexer lexer = new HFLLexer(input);
       lexer.removeErrorListeners();
       lexer.addErrorListener(ThrowingErrorListener.INSTANCE);
        
       // create a buffer of tokens pulled from the lexer
       CommonTokenStream tokens = new CommonTokenStream(lexer);

       // create a parser that feeds off the tokens buffer
       HFLParser parser = new HFLParser(tokens);
       parser.removeErrorListeners();
       parser.addErrorListener(new ExtendedErrorListener.CustomErrorListener()); //add our own listener
    
       
       ExtendedHFLListener listener = new ExtendedHFLListener(parser, lexer); // We defined our own parser listener

       ParseTree tree = parser.triple();
       //walk the tree to fill the AST
       ParseTreeWalker walker = new ParseTreeWalker();
       walker.walk(listener, tree);

       //Get the S block
       ArrayList<ASTNode> statements = (ArrayList<ASTNode>) AST.root.children.get(1).children.get(0).children;
       Collections.reverse(statements); //reverse for the weakest precondition function

       //Get {Q}
       FormulaNode Q = (FormulaNode) AST.root.children.get(2).children.get(1);

       //Get {P}
       FormulaNode P = (FormulaNode) AST.root.children.get(0).children.get(1);

       //Get the text representation for Q
       String finalFormula = Q.printn();

       //Send finalFormula to the weakest precondition function to calculate the final formula
       for (int i = 0; i < statements.size(); i++) {

           if (statements.get(i) instanceof StatementNode)
               finalFormula = WeakestPrecondition.wp((/*(StatementNode)*/statements.get(i)), finalFormula);
       }

       //Append the P=>P'
       String g = "( " + P.printn() + " => " + finalFormula + " )";

       //Send to Z#SolverHelper
      return  Z3SolverHelper.Solve(g, false);

    }

    
    public static boolean SolvePredAndPre(String p1, String p2, String sign, boolean satOnly){


     FormulaNode P1 ;    	  
     P1 = getFormulaNode("{"+p1+"}");

     FormulaNode P2 ;    	  
     P2 = getFormulaNode("{"+p2+"}");
     
    //Append the P & P' or P=>P'
    String g = "( " + P1.printn() + sign + P2.printn() + " )";

    //Send to Z#SolverHelper
   return  Z3SolverHelper.Solve(g, satOnly);

 }


	private static FormulaNode getFormulaNode(String p1) {
		FormulaNode P;
		ANTLRInputStream input = new ANTLRInputStream(p1);

		// create a lexer that feeds off of input CharStream
		HFLLexer lexer = new HFLLexer(input);
		lexer.removeErrorListeners();
		lexer.addErrorListener(ThrowingErrorListener.INSTANCE);
		 
		// create a buffer of tokens pulled from the lexer
		CommonTokenStream tokens = new CommonTokenStream(lexer);

		// create a parser that feeds off the tokens buffer
		HFLParser parser = new HFLParser(tokens);
		parser.removeErrorListeners();
		parser.addErrorListener(new ExtendedErrorListener.CustomErrorListener()); //add our own listener
 
		
		ExtendedHFLListener listener = new ExtendedHFLListener(parser, lexer); // We defined our own parser listener

		
		 AST.root = new ASTNode(null, 0, "P", false);
	     AST.current = AST.root;
	        
	        
		ParseTree tree = parser.p();
		//walk the tree to fill the AST
		ParseTreeWalker walker = new ParseTreeWalker();
		walker.walk(listener, tree);

		//Get {P}
		  P = (FormulaNode) AST.root.children.get(0).children.get(1);
		return P;
	}

 
 
 
    

    private enum Operator {
        //Defines legit operators precedence
        ADD(1), SUBTRACT(2), MULTIPLY(3), DIVIDE(4), LT(5), LTE(6), GT(7), GTE(8), IMP(9), AND(10), OR(11), NOT(12), NOTEQUALS(14), EQUALS(14), ForAll(13), Exists(13);

        final int precedence;

        Operator(int p) {
            precedence = p;
        }
    }

    //Holds operator translation
    private static Map<String, Operator> ops = new HashMap<String, Operator>() {/**
         *
         */
        private static final long serialVersionUID = 1L;

    {

        put("+", Operator.ADD);
        put("-", Operator.SUBTRACT);
        put("*", Operator.MULTIPLY);
        put("/", Operator.DIVIDE);

        put("<", Operator.LT);
        put("<=", Operator.LTE);
        put(">", Operator.GT);
        put(">=", Operator.GTE);

        put("=>", Operator.IMP);
        put("&", Operator.AND);
        put("|", Operator.OR);
        put("!", Operator.NOT);
        put("=", Operator.EQUALS);
        put("forall", Operator.ForAll);
        put("exists", Operator.Exists);
        put("!=", Operator.NOTEQUALS);

    }

    };

    //for quantifier variables
    public static ArrayList<String> variables = new ArrayList<String>();

    //Variables that are already declared in SMT file
    public static ArrayList<String> declaredVariables = new ArrayList<String>();

    public static String getZ3Operator(String op) {

        switch (op) {
            case "&":
                return "and";
            case "|":
                return "or";
            case "!":
                return "not";
            case "<=>":
                return "=";
            case "=":
                return "=";
            case "!=":
                return "=";
            

        }

        return op;
    }

    private static boolean isHigerPrec(String op, String sub) {
        return (ops.containsKey(sub) && ops.get(sub).precedence >= ops.get(op).precedence);
    }

    public static boolean Solve(String formula, boolean satOnly) {
          /*
          IMPLEMENTATION SKETCH:
          IF a node is an operator then append it and open parenthesis, if an operator and quantifier then declare variable inside 2 paranthesis
          If the node is a quantifier variable then remove the ? from it
          If the node is a negation then append not keyword
          Then print right node and left node recursively
          If leafs are reached then print as is
         */

        //EFFECTS: Returns an infix SMT syntax for our parse tree
        //HELPS: this.Solve

        //reset quantifier variables
        variables = new ArrayList<String>();

        formula = formula.replaceAll("\\(", " ( ");
        formula = formula.replaceAll("\\)", " ) ");

        //call postfix on formula to get a list of tokens in postfix notation
        ArrayList<String> output = postfix(formula);

        //push array into a tree of SMTNodes
        Deque<SMTNode> stack = new LinkedList<>();

        for (String element : output) {

            //if operand and not negation
            if (ops.containsKey(element) && !element.equals("!")) {

                SMTNode rightOperand = stack.pop();
                SMTNode leftOperand = stack.pop();

                SMTNode bn = new SMTNode(element);
                bn.left = leftOperand;
                bn.right = rightOperand;
                stack.push(bn);

                if (element.equals("!=")) {
                    SMTNode nd = stack.pop();
                    nd.negation = true;
                    stack.push(nd);

                }
                //if negation pop to add negation flag
            } else if (ops.containsKey(element) && element.equals("!")) {
                SMTNode nd = stack.pop();
                nd.negation = true;
                stack.push(nd);

            } else {
                //if a leaf
                stack.push(new SMTNode(element));
                if (!element.contains("?"))
                    variables.add(element);
            }
        }

        //Generate SMT file

        generateSMTFile(stack, satOnly);
        
        
        //Calling the Z3

        //Use Z3 Java API
        HashMap<String, String> cfg = new HashMap<String, String>();
        cfg.put("model", "true");
        Context ctx = new Context(cfg);

        //Get SMT file
        BoolExpr a = ctx.mkAnd(ctx.parseSMTLIB2File(Paths.get("").toAbsolutePath().normalize().toString() + "/test.smt", null, null, null, null));

        //Make a solver object
        Solver s = ctx.mkSolver();

        //Add expression to it from ast file
        s.add((a));

        //check sat
        Status res = s.check();

       return res == Status.UNSATISFIABLE;
    }

    private static void generateSMTFile(Deque<SMTNode> stack, boolean satOnly) {
        //EFFECTS: Generate a file test.smt that contains the formula to be proved
        //HELPS: this.solve

        StringBuilder sb = new StringBuilder();

        Set<String> hs = new HashSet<>();
        hs.addAll(variables);
        variables.clear();
        variables.addAll(hs);

        for (String constant :
                variables) {

            Boolean isNumber = false;
            try {
                Integer.parseInt(constant);
                isNumber = true;
            } catch (NumberFormatException e) {
                isNumber = false;
            }

            //Declare constanct variables
            if (!isNumber && !constant.toLowerCase().equals("true")
					&& !constant.toLowerCase().equals("false"))
                if (Character.isUpperCase(constant.charAt(0)) )
                    sb.append("(declare-const " + constant + " Bool)\n");

                else

                    sb.append("(declare-const " + constant + " Int)\n");

        }
        
        if(!satOnly) {
        	   //Print assert not "formula" to check for satisfiability
            sb.append("(assert  ( not " + printNode(stack.getFirst()) + " ) ) \n");
        }else {
        	
        	  sb.append("(assert " + printNode(stack.getFirst()) + " )\n");
        }
     

        //Print check command
        sb.append("(check-sat)\n");

        try {

            //Output file to working directory
            System.out.println();
            PrintWriter outputFile = new PrintWriter(new File("test.smt"));
            outputFile.println(sb);
            outputFile.close();
            System.out.println(sb);

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }

    public static String printNode(SMTNode n) {
        /*
          IMPLEMENTATION SKETCH:
          IF a node is an operator then append it and open parenthesis, if an operator and quantifier then declare variable inside
           2 paranthesis
          If the node is a quantifier variable then remove the ? from it
          If the node is a negation then append not keyword
          Then print right node and left node recursively
          If leafs are reached then print as is
         */

        //EFFECTS: Returns an infix SMT syntax for our parse tree
        //HELPS: this.Solve

        String print = "";

        //if the node is an operator
        if (ops.containsKey(n.data)) {

            //if an operator and quantifier then declare variable inside 2 parenthesis
            if (n.data.equals("forall") || n.data.equals("exists"))
                declaredVariables = new ArrayList<String>();

            //if a node is an operator then append it and open parenthesis
            print = print + " ( " + getZ3Operator(n.data) + " ";

        } else {

            //  If the node is a quantifier variable then remove the ? from it
            if (n.data.contains("?")) {

                if (!declaredVariables.contains(n.data)) {
                    print = print + " ( ( " + new StringBuilder(n.data).deleteCharAt(0) + " Int ) )";
                    declaredVariables.add(n.data);
                } else {
                    print = print + " " + new StringBuilder(n.data).deleteCharAt(0) + " ";
                }
            } else

                print = print + " " + n.data + " ";
        }
        //if leaf then just print
        if (n.left == null && n.right == null) {
        	    if(print.toLowerCase().contains("true"))
        	    		return "true ";
        	    if(print.toLowerCase().contains("false"))
        	      	return "false ";
				 
            return print;
        }
        //Then print right node and left node recursively
        if (n.negation) {
            //If the node is a negation then append not keyword
            return "( not " + print + printNode(n.left) + printNode(n.right) + " ) ) ";

        } else {
            return print + printNode(n.left) + printNode(n.right) + " ) ";

        }
    }

    public static ArrayList<String> postfix(String infix) {

        //EFFECTS: Returns a list of tokens in infix notation
        //HELPS: this.solve

        ArrayList<String> output = new ArrayList<String>();
        Deque<String> stack = new LinkedList<>();

        StringTokenizer tokenizer = new StringTokenizer(infix);

        //tokenize string
        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken();
            // operator
            if (ops.containsKey(token)) {
                while (!stack.isEmpty() && isHigerPrec(token, stack.peek()))
                    output.add(stack.pop());
                stack.push(token);

                // left parenthesis
            } else if (token.equals("(")) {
                stack.push(token);

                // right parenthesis
            } else if (token.equals(")")) {
                while (!stack.peek().equals("("))
                    output.add(stack.pop());
                stack.pop();

                // digit
            } else {
                output.add(token);
            }
        }

        while (!stack.isEmpty())
            output.add(stack.pop());

        // Collections.reverse(output);
        return output;
    }

}

class SMTNode {

    //OVERVIEW: this helps in generating proper smt syntax, 
	// it is a tree data structure that holds operands on nodes and variables on leaves

    String data;
    boolean negation;
    SMTNode left;
    SMTNode right;

    public SMTNode(String d) {
        this.data = d;
    }

}